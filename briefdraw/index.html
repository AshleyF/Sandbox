<!DOCTYPE html>
<title>BriefDraw Demo</title>
<meta charset="utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
  svg, canvas {
    border: 1px dashed #AAA;
  }

  canvas {
    width: 400px;
    height: 400px;
  }

  #error {
    color: red;
  }
</style>
<h2>BriefDraw Demo</h2>
<p>
  Theta: <input type="range" id="theta" min="0" max="1" step="0.001" value="0" />
  Delta: <input type="range" id="delta" min="0" max="1" step="0.001" value="0" />
</p>
<canvas id=canvas0 style="width:400px;height:400px"></canvas>
<textarea id=brief cols=80 rows=26>
[ path
200 700 move
500 200 line
800 700 line
close ] 'triangle1 def

[ path
200 300 move
500 800 line
800 300 line
close ] 'triangle2 def

triangle1 triangle2

union
\intersect
\difference
\xor

path
500 500 100 delta + 200 theta 0 3 true ellipse-rotated-partial
500 900 line
close
difference
</textarea>
<br />
<span id=error></span>
<span id=status></span>
<script type="text/javascript" src="./pathkit.js"></script>
<script type="text/javascript" charset="utf-8">
PathKitInit({
    locateFile: (file) => './' + file,
  }).then((PathKit) => {
    window.PathKit = PathKit;
    BriefExample(PathKit);
  });

  function setCanvasSize(ctx, width, height) {
    ctx.canvas.width = width;
    ctx.canvas.height = height;
  }

var dstack = [];
var gstack = [];

function brief(source, PathKit) {
  function addref(path) { path.ref++; }
  function release(path) { if (path.ref == 1) path.value.delete(); else path.ref--; }
  function popAny(stack) {
    if (stack.length == 0) throw "Stack underflow";
    return stack.pop();
  }
  function peekAny(stack) { return stack[stack.length - 1]; }
  function pushAny(value, stack) { return stack.push(value); }
  function pushNum(n, stack) { pushAny({ kind: "num", value: n }, stack); }
  function pushBool(b, stack) { pushAny({ kind: "num", value: b }, stack); }
  function popKind(kind, stack) {
    var x = popAny(stack);
    if (x.kind != kind) throw "Expected " + kind + " found " + x.kind;
    return x;
  }
  function popNum(stack) { return popKind("num", stack); }
  function popPath(stack) { return popKind("path", stack); }
  function popQuote(stack) { return popKind("quote", stack); }
  function popSymbol(stack) { return popKind("sym", stack); }
  function binOp(fn) {
    var x = popNum(dstack).value;
    var y = popNum(dstack).value;
    pushNum(fn(x, y), dstack);
  }
  function pathOp(op) {
    var pathy = popPath(gstack);
    var pathx = popPath(gstack);
    var p = PathKit.MakeFromOp(pathx.value, pathy.value, op);
    gstack.push({ kind: "path", ref: 1, value: p });
    release(pathx);
    release(pathy);
  }
  function dup(stack) {
    var x = popAny(stack); stack.push(x); stack.push(x);
    if (x.kind == "path") { addref(x); }
  }
  function drop(stack) {
    var x = popAny(stack);
    if (x.kind == "path") { release(x); }
  }
  function swap(stack) {
    var x = popAny(stack);
    var y = popAny(stack);
    pushAny(x, stack)
    pushAny(y, stack)
  }
  function pathChain0(fn) {
    var p = popPath(gstack);
    p.value = fn(p.value);
    pushAny(p, gstack);
  }
  function pathChain1(fn) {
    var x = popNum(dstack).value;
    pathChain0(function(p) { return fn(p, x); })
  }
  function pathChain2(fn) {
    var y = popNum(dstack).value;
    var x = popNum(dstack).value;
    pathChain0(function(p) { return fn(p, x, y); })
  }
  function pathChain3(fn) {
    var z = popNum(dstack).value;
    var y = popNum(dstack).value;
    var x = popNum(dstack).value;
    pathChain0(function(p) { return fn(p, x, y, z); })
  }
  function pathChain4(fn) {
    var w = popNum(dstack).value;
    var z = popNum(dstack).value;
    var y = popNum(dstack).value;
    var x = popNum(dstack).value;
    pathChain0(function(p) { return fn(p, x, y, z, w); })
  }
  function pathChain5(fn) {
    var v = popNum(dstack).value;
    var w = popNum(dstack).value;
    var z = popNum(dstack).value;
    var y = popNum(dstack).value;
    var x = popNum(dstack).value;
    pathChain0(function(p) { return fn(p, x, y, z, w, v); })
  }
  function pathChain6(fn) {
    var u = popNum(dstack).value;
    var v = popNum(dstack).value;
    var w = popNum(dstack).value;
    var z = popNum(dstack).value;
    var y = popNum(dstack).value;
    var x = popNum(dstack).value;
    pathChain0(function(p) { return fn(p, x, y, z, w, v, u); })
  }
  function pathChain7(fn) {
    var t = popNum(dstack).value;
    var u = popNum(dstack).value;
    var v = popNum(dstack).value;
    var w = popNum(dstack).value;
    var z = popNum(dstack).value;
    var y = popNum(dstack).value;
    var x = popNum(dstack).value;
    pathChain0(function(p) { return fn(p, x, y, z, w, v, u, t); })
  }
  function pathChain8(fn) {
    var s = popNum(dstack).value;
    var t = popNum(dstack).value;
    var u = popNum(dstack).value;
    var v = popNum(dstack).value;
    var w = popNum(dstack).value;
    var z = popNum(dstack).value;
    var y = popNum(dstack).value;
    var x = popNum(dstack).value;
    pathChain0(function(p) { return fn(p, x, y, z, w, v, u, t, s); })
  }
  function unaryPathChain(fn) {
    var p = popPath(gstack);
    p.value = fn(p.value);
    pushAny(p, gstack);
  }
  function applyQuote(q) {
    return function() { q.value.forEach(w => w()); }
  }
  function evalWord(word) {
    var n = parseFloat(word);
    if (isNaN(n)) {
      if (word[0] == "'") {
        return function() {
          pushAny({ kind: "sym", value: word.substring(1) }, dstack);
        }
      } else {
        var apply = dictionary[word];
        if (apply) {
          return function() {
            try {
                apply();
            } catch (e) {
                error += " !" + e;
            }
          };
        } else {
            error += " ?" + word;
            return function() { /* NOP */ };
        }
      }
    } else {
      return function() {
        pushNum(n, dstack)
      };
    }
  }
  var dictionary = {
    "pi": function() { pushNum(Math.PI, dstack); },
    "2pi": function() { pushNum(2 * Math.PI, dstack); },
    "e": function() { pushNum(Math.E, dstack); },
    "theta": function() { pushNum(document.getElementById("theta").value * 2 * Math.PI, dstack); },
    "delta": function() { pushNum(document.getElementById("delta").value * 1000, dstack); },
    "true": function() { pushBool(true, dstack); },
    "false": function() { pushBool(false, dstack); },
    "+": function() { binOp(function (x, y) { return y + x; }); },
    "-": function() { binOp(function (x, y) { return y - x; }); },
    "*": function() { binOp(function (x, y) { return y * x; }); },
    "/": function() { binOp(function (x, y) { return y / x; }); },
    "dup": function() { dup(dstack); },
    "gdup": function() { dup(gstack); },
    "drop": function() { drop(dstack); },
    "gdrop": function() { drop(gstack); },
    "swap": function() { swap(dstack); },
    "gswap": function() { swap(gstack); },
    "path": function() { gstack.push({ kind: "path", ref: 1, value: PathKit.NewPath() }); },
    "move": function() { pathChain2(function(p, x, y) { return p.moveTo(x, y); })},
    "line": function() { pathChain2(function(p, x, y) { return p.lineTo(x, y); })},
    "ellipse-rotated-partial": function() { pathChain8(function(p, x, y, rx, ry, rot, start, end, ccw) { return p.ellipse(x, y, rx, ry, rot, start, end, ccw); }); }, // x, y, radiusX, radiusY, rotation, startAngle, endAngle, ccw
    "ellipse-rotated": function() { pathChain5(function(p, x, y, rx, ry, rot) { return p.ellipse(x, y, rx, ry, rot, 0, 0); }); },
    "ellipse": function() { pathChain4(function(p, x, y, rx, ry) { return p.ellipse(x, y, rx, ry, 0, 0, 0); }); },
    "simplify": function() { pathChain0(function(p) { return p.simplify(); }) },
    "close": function() { unaryPathChain(function (p) { return p.closePath(); })},
    "intersect": function() { pathOp(PathKit.PathOp.INTERSECT); },
    "union": function() { pathOp(PathKit.PathOp.UNION); },
    "difference": function() { pathOp(PathKit.PathOp.DIFFERENCE); }, // gswap for REVERSE_DIFFERENCE
    "xor": function() { pathOp(PathKit.PathOp.XOR); },
    "[": function() {
      pushAny({ kind: "quote", open: true, value: [] }, dstack);
    },
    "]": function() {
      var q = popQuote(dstack);
      var t = peekAny(dstack);
      var nested = t && t.kind == "quote" && t.open; // TODO
      if (nested) {
        t.value.push(applyQuote(q));
      } else {
        q.open = false;
        pushAny(q, dstack);
      }
    },
    "apply": function() { applyQuote(popQuote(dstack)); },
    "def": function() {
      var name = popSymbol(dstack).value;
      var quote = popQuote(dstack);
      dictionary[name] = applyQuote(quote);
    }
  };
  var error = "";
  var lines = source.match(/[^\r\n]+/g);
  if (lines) {
    for (var l in lines) {
      var line = lines[l];
      if (!line.startsWith("\\")) {
        var words = line.match(/\S+/g);
        if (words) {
          for (var w = 0; w < words.length; w++) {
            var word = words[w];
            var immediate = word == "[" || word == "]";
            var expr = evalWord(word);
            var t = peekAny(dstack);
            if (!immediate && t && t.kind == "quote" && t.open)
              t.value.push(expr);
            else
              expr();
          }
        }
      }
    }
  }
  document.getElementById("error").innerText = (error ? "ERROR: " + error + "\n" : "");
}

function showStacks() {
  function displayStack(s) {
    var disp = ""
    for (var i in s) {
        var x = s[i];
        switch (x.kind) {
          case "path": disp += "path-" + x.ref + " "; break;
          case "quote": disp += "[" + x.value.length + "] "; break;
          case "num": disp += "#" + x.value + " "; break;
          case "sym": disp += "'" + x.value + " "; break;
          case "bool": disp += "B" + x.value + " "; break;
          default: disp += x.value + ":" + x.kind;
        }
    }
    return disp;
  }

  var dstackOut = displayStack(dstack);
  var gstackOut = displayStack(gstack);

  document.getElementById("status").innerText = "Data: " + dstackOut + "\nGraphics: " + gstackOut;
}

function drawToCanvas(name) {
  let ctx = document.getElementById(name).getContext('2d');
  setCanvasSize(ctx, 1000, 1000);
  ctx.strokeStyle = 'black';
  ctx.fillStyle = 'gainsboro';
  ctx.scale(1, 1);

  for (var d in gstack) {
    ctx.beginPath();
    var path = gstack[d].value;
    path.toCanvas(ctx);
    ctx.fill();
    ctx.stroke();
  }

  for (var d in gstack) {
    var path = gstack[d];
    if (path.ref > 0) {
      path.value.delete();
      path.ref = 0; // including clones (no double-delete)
    }
  }
}

function update() {
  var source = document.getElementById("brief");
  dstack = [];
  gstack = [];
  brief(source.value, PathKit);
  showStacks();
  drawToCanvas("canvas0");
}

function BriefExample(PathKit) {
  update();
  document.getElementById("brief").addEventListener('input', (event) => update()); 
  document.getElementById("theta").addEventListener('input', (event) => update()); 
  document.getElementById("delta").addEventListener('input', (event) => update()); 
}

// TODO: remove the below examples

function OutputsExample(PathKit) {
  let simpleStr = firstPath.toSVGString();

  // create Path2D object and use it in a Canvas.
  let path2D = firstPath.toPath2D();
  ctx = document.getElementById('canvas2').getContext('2d');
  setCanvasSize(ctx, 200, 200);
  ctx.canvas.width = 200
  ctx.scale(8, 8);
  ctx.fillStyle = 'purple';
  ctx.strokeStyle = 'orange';
  ctx.fill(path2D);
  ctx.stroke(path2D);

  // clean up WASM memory
  // See http://kripken.github.io/emscripten-site/docs/porting/connecting_cpp_and_javascript/embind.html?highlight=memory#memory-management
  firstPath.delete();
  secondPath.delete();
}

function Path2DExample(PathKit) {
  let objs = [new Path2D(), PathKit.NewPath(), new Path2D(), PathKit.NewPath()];
  let canvases = [
    document.getElementById('canvas3').getContext('2d'),
    document.getElementById('canvas4').getContext('2d')
  ];

  for (i = 0; i <= 1; i++) {
    let path = objs[i];

    path.moveTo(20, 5);
    path.lineTo(30, 20);
    path.lineTo(40, 10);
    path.lineTo(50, 20);
    path.lineTo(60, 0);
    path.lineTo(20, 5);

    path.moveTo(20, 80);
    path.bezierCurveTo(90, 10, 160, 150, 190, 10);

    path.moveTo(36, 148);
    path.quadraticCurveTo(66, 188, 120, 136);
    path.lineTo(36, 148);

    path.rect(5, 170, 20, 20);

    path.moveTo(150, 180);
    path.arcTo(150, 100, 50, 200, 20);
    path.lineTo(160, 160);

    path.moveTo(20, 120);
    path.arc(20, 120, 18, 0, 1.75 * Math.PI);
    path.lineTo(20, 120);

    let secondPath = objs[i+2];
    secondPath.ellipse(130, 25, 30, 10, -1*Math.PI/8, Math.PI/6, 1.5*Math.PI, false);

    path.addPath(secondPath);

    let m = document.createElementNS('http://www.w3.org/2000/svg', 'svg').createSVGMatrix();
    m.a = 1; m.b = 0;
    m.c = 0; m.d = 1;
    m.e = 0; m.f = 20.5;

    path.addPath(secondPath, m);
    // With PathKit, one can also just provide the 6 params as floats, to avoid
    // the overhead of making an SVGMatrix
    // path.addPath(secondPath, 1, 0, 0, 1, 0, 20.5);

    canvasCtx = canvases[i];
    canvasCtx.fillStyle = 'blue';
    setCanvasSize(canvasCtx, 300, 300);
    canvasCtx.scale(1.5, 1.5);
    if (path.toPath2D) {
      canvasCtx.stroke(path.toPath2D());
    } else {
      canvasCtx.stroke(path);
    }
  }

  objs[1].delete();
}

// see https://fiddle.skia.org/c/@discrete_path
function drawStar(path) {
  let R = 115.2, C = 128.0;
  path.moveTo(C + R + 22, C);
  for (let i = 1; i < 8; i++) {
    let a = 2.6927937 * i;
    path.lineTo(C + R * Math.cos(a) + 22, C + R * Math.sin(a));
  }
  path.closePath();
  return path;
}

function PathEffectsExample(PathKit) {
  let effects = [
    // no-op
    (path) => path,
    // dash
    (path, counter) => path.dash(10, 3, counter/5),
    // trim (takes optional 3rd param for returning the trimmed part
    // or the complement)
    (path, counter) => path.trim((counter/100) % 1, 0.8, false),
    // simplify
    (path) => path.simplify(),
    // stroke
    (path, counter) => path.stroke({
      width: 10 * (Math.sin(counter/30) + 1),
      join: PathKit.StrokeJoin.BEVEL,
      cap: PathKit.StrokeCap.BUTT,
      miter_limit: 1,
    }),
    // "offset effect", that is, making a border around the shape.
    (path, counter) => {
      let orig = path.copy();
      path.stroke({
        width: 10 + (counter / 4) % 50,
        join: PathKit.StrokeJoin.ROUND,
        cap: PathKit.StrokeCap.SQUARE,
      })
        .op(orig, PathKit.PathOp.DIFFERENCE);
      orig.delete();
    },
    (path, counter) => {
      let simplified = path.simplify().copy();
      path.stroke({
        width: 2 + (counter / 2) % 100,
        join: PathKit.StrokeJoin.BEVEL,
        cap: PathKit.StrokeCap.BUTT,
      })
        .op(simplified, PathKit.PathOp.REVERSE_DIFFERENCE);
      simplified.delete();
    }
  ];

  let names = ["(plain)", "Dash", "Trim", "Simplify", "Stroke", "Grow", "Shrink"];

  let counter = 0;
  function frame() {
    counter++;
    for (let i = 0; i < effects.length; i++) {
      let path = PathKit.NewPath();
      drawStar(path);

      // The transforms apply directly to the path.
      effects[i](path, counter);

      let ctx = document.getElementById(`canvas${i+5}`).getContext('2d');
      setCanvasSize(ctx, 300, 300);
      ctx.strokeStyle = '#3c597a';
      ctx.fillStyle = '#3c597a';
      if (i >=4 ) {
        ctx.fill(path.toPath2D(), path.getFillTypeString());
      } else {
        ctx.stroke(path.toPath2D());
      }

      ctx.font = '42px monospace';

      let x = 150-ctx.measureText(names[i]).width/2;
      ctx.strokeText(names[i], x, 290);

      path.delete();
    }
    window.requestAnimationFrame(frame);
  }
  window.requestAnimationFrame(frame);
}

function MatrixTransformExample(PathKit) {
  // Creates an animated star that twists and moves.
  let ctx = document.getElementById('canvasTransform').getContext('2d');
  setCanvasSize(ctx, 300, 300);
  ctx.strokeStyle = '#3c597a';

  let path = drawStar(PathKit.NewPath());
  // TODO(kjlubick): Perhaps expose some matrix helper functions to allow
  // clients to build their own matrices like this?
  // These matrices represent a 2 degree rotation and a 1% scale factor.
  let scaleUp = [1.0094, -0.0352,  3.1041,
                  0.0352,  1.0094, -6.4885,
                  0     ,  0      , 1];

  let scaleDown = [ 0.9895, 0.0346, -2.8473,
                    -0.0346, 0.9895,  6.5276,
                    0     , 0     ,  1];

  let i = 0;
  function frame(){
    i++;
    if (Math.round(i/100) % 2) {
      path.transform(scaleDown);
    } else {
      path.transform(scaleUp);
    }

    ctx.clearRect(0, 0, 300, 300);
    ctx.stroke(path.toPath2D());

    ctx.font = '42px monospace';
    let x = 150-ctx.measureText('Transform').width/2;
    ctx.strokeText('Transform', x, 290);

    window.requestAnimationFrame(frame);
  }
  window.requestAnimationFrame(frame);
}

function FilledSVGExample(PathKit) {
  let innerRect = PathKit.NewPath();
  innerRect.rect(80, 100, 40, 40);

  let outerRect = PathKit.NewPath();
  outerRect.rect(50, 10, 100, 100)
            .op(innerRect, PathKit.PathOp.XOR);

  let str = outerRect.toSVGString();

  let diffSVG = document.createElementNS('http://www.w3.org/2000/svg', 'path');
  diffSVG.setAttribute('stroke', 'red');
  diffSVG.setAttribute('fill', 'black');
  // force fill-rule to nonzero to demonstrate difference
  diffSVG.setAttribute('fill-rule', 'nonzero');
  diffSVG.setAttribute('d', str);
  document.getElementById('svg2').appendChild(diffSVG);

  let unionSVG = document.createElementNS('http://www.w3.org/2000/svg', 'path');
  unionSVG.setAttribute('stroke', 'red');
  unionSVG.setAttribute('fill', 'black');
  // ask what the path thinks fill-rule should be ('evenodd')
  // SVG and Canvas both use the same keys ('nonzero' and 'evenodd') and both
  // default to 'nonzero', so one call supports both.
  unionSVG.setAttribute('fill-rule', outerRect.getFillTypeString());
  unionSVG.setAttribute('d', str);
  document.getElementById('svg3').appendChild(unionSVG);

  outerRect.delete();
  innerRect.delete();
}

function CubicSolverExample(PathKit) {
  let ctx = document.getElementById('cubics').getContext('2d');
  setCanvasSize(ctx, 300, 300);
  // Draw lines between cp0 (0, 0) and cp1 and then cp2 and cp3 (1, 1)
  // scaled up to be on a 300x300 grid instead of unit square
  ctx.strokeStyle = 'black';
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(0.1 * 300, 0.5*300);

  ctx.moveTo(0.5 * 300, 0.1*300);
  ctx.lineTo(300, 300);
  ctx.stroke();


  ctx.strokeStyle = 'green';
  ctx.beginPath();

  for (let x = 0; x < 300; x++) {
    // scale X into unit square
    let y = PathKit.cubicYFromX(0.1, 0.5, 0.5, 0.1, x/300);
    ctx.arc(x, y*300, 2, 0, 2*Math.PI);
  }
  ctx.stroke();
}
</script>